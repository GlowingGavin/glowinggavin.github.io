<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AlienGamer Chess</title>
<style>
  body {
    background-color: #111;
    color: #fff;
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 80px);
    grid-template-rows: repeat(8, 80px);
    border: 4px solid #000;
    margin-bottom: 20px;
  }
  .square {
    width: 80px;
    height: 80px;
    display: flex;
    justify-content: center;
    align-items: center;
    user-select: none;
  }
  .light { background: #f0d9b5; }
  .dark { background: #b58863; }
  .piece {
    width: 72px;
    height: 72px;
    cursor: grab;
  }
  #turn {
    font-size: 1.3rem;
    letter-spacing: 1px;
  }
</style>
</head>
<body>
  <div id="board"></div>
  <div id="turn">White to move</div>

<script>
const files = ['a','b','c','d','e','f','g','h'];
const ranks = [8,7,6,5,4,3,2,1];
const board = document.getElementById('board');
const turnDisplay = document.getElementById('turn');

let startPos = {
  a8: 'br', b8: 'bn', c8: 'bb', d8: 'bq', e8: 'bk', f8: 'bb', g8: 'bn', h8: 'br',
  a7: 'bp', b7: 'bp', c7: 'bp', d7: 'bp', e7: 'bp', f7: 'bp', g7: 'bp', h7: 'bp',
  a2: 'wp', b2: 'wp', c2: 'wp', d2: 'wp', e2: 'wp', f2: 'wp', g2: 'wp', h2: 'wp',
  a1: 'wr', b1: 'wn', c1: 'wb', d1: 'wq', e1: 'wk', f1: 'wb', g1: 'wn', h1: 'wr'
};

let gameState = structuredClone(startPos);
let turn = 'w';

function drawBoard() {
  board.innerHTML = '';
  for (let r of ranks) {
    for (let f of files) {
      const square = document.createElement('div');
      square.classList.add('square');
      if ((files.indexOf(f) + ranks.indexOf(r)) % 2 === 0)
        square.classList.add('light');
      else
        square.classList.add('dark');
      const id = f + r;
      square.id = id;
      const piece = gameState[id];
      if (piece) {
        const img = document.createElement('img');
        img.src = `pieces/${piece}.png`;
        img.classList.add('piece');
        img.draggable = true;
        square.appendChild(img);
      }
      board.appendChild(square);
    }
  }
  turnDisplay.textContent = (turn === 'w') ? 'White to move' : 'Black to move';
  enableDragAndDrop(); // âœ… reattach events
}

function pieceColor(piece) { return piece ? piece[0] : null; }
function pieceType(piece) { return piece ? piece[1] : null; }

function clearPath(from, to) {
  const fx = files.indexOf(from[0]);
  const fy = parseInt(from[1]);
  const tx = files.indexOf(to[0]);
  const ty = parseInt(to[1]);
  const dx = Math.sign(tx - fx);
  const dy = Math.sign(ty - fy);
  let x = fx + dx;
  let y = fy + dy;
  while (x !== tx || y !== ty) {
    const sq = files[x] + y;
    if (gameState[sq]) return false;
    x += dx; y += dy;
  }
  return true;
}

function isLegalMove(from, to) {
  const piece = gameState[from];
  if (!piece) return false;
  const color = pieceColor(piece);
  const type = pieceType(piece);
  const fx = files.indexOf(from[0]);
  const fy = parseInt(from[1]);
  const tx = files.indexOf(to[0]);
  const ty = parseInt(to[1]);
  const dx = tx - fx;
  const dy = ty - fy;
  const targetPiece = gameState[to];
  if (targetPiece && pieceColor(targetPiece) === color) return false;

  switch(type) {
    case 'p': { // pawn
      const dir = (color === 'w') ? 1 : -1;
      const startRank = (color === 'w') ? 2 : 7;
      if (dx === 0 && !targetPiece) {
        if (ty - fy === dir) return true;
        if (fy === startRank && ty - fy === 2 * dir &&
            !gameState[files[fx] + (fy + dir)]) return true;
      } else if (Math.abs(dx) === 1 && ty - fy === dir && targetPiece) return true;
      return false;
    }
    case 'r':
      if (fx === tx || fy === ty) return clearPath(from, to);
      return false;
    case 'b':
      if (Math.abs(dx) === Math.abs(dy)) return clearPath(from, to);
      return false;
    case 'q':
      if (fx === tx || fy === ty || Math.abs(dx) === Math.abs(dy))
        return clearPath(from, to);
      return false;
    case 'n':
      return (Math.abs(dx) === 1 && Math.abs(dy) === 2) ||
             (Math.abs(dx) === 2 && Math.abs(dy) === 1);
    case 'k':
      return Math.abs(dx) <= 1 && Math.abs(dy) <= 1;
  }
  return false;
}

// ðŸ§© Drag-and-drop handlers reattached each redraw
function enableDragAndDrop() {
  let draggedPiece = null;
  let sourceSquare = null;

  document.querySelectorAll('.piece').forEach(piece => {
    piece.addEventListener('dragstart', e => {
      const sq = e.target.parentElement.id;
      const pieceCode = gameState[sq];
      if (pieceColor(pieceCode) !== turn) {
        e.preventDefault();
        return;
      }
      draggedPiece = e.target;
      sourceSquare = sq;
      setTimeout(() => (draggedPiece.style.visibility = 'hidden'), 0);
    });

    piece.addEventListener('dragend', e => {
      if (draggedPiece) draggedPiece.style.visibility = 'visible';
      draggedPiece = null;
    });
  });

  document.querySelectorAll('.square').forEach(sq => {
    sq.addEventListener('dragover', e => e.preventDefault());
    sq.addEventListener('drop', e => {
      e.preventDefault();
      const targetSquare = e.target.closest('.square').id;
      if (!sourceSquare || !draggedPiece) return;

      if (isLegalMove(sourceSquare, targetSquare)) {
        gameState[targetSquare] = gameState[sourceSquare];
        delete gameState[sourceSquare];
        turn = (turn === 'w') ? 'b' : 'w';
        drawBoard();
      }
      sourceSquare = null;
    });
  });
}

drawBoard();
</script>
</body>
</html>
