<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>AlienGamer Chess</title>
<style>
  body {
    background: #222;
    color: white;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 80px);
    grid-template-rows: repeat(8, 80px);
    border: 3px solid #333;
    margin-top: 20px;
  }
  .square {
    width: 80px;
    height: 80px;
    position: relative;
  }
  .light { background: #f0d9b5; }
  .dark { background: #b58863; }
  .piece {
    width: 80px;
    height: 80px;
    user-select: none;
  }
  .highlight {
    outline: 3px solid yellow;
  }
  .eval-icon {
    position: absolute;
    top: 2px;
    right: 2px;
    width: 22px;
    height: 22px;
  }
  .overlay {
    position: absolute;
    inset: 0;
    opacity: 0.35;
    border-radius: 2px;
  }
</style>
</head>
<body>
<h2 id="turn">Loading...</h2>
<div id="board"></div>

<!-- ✅ Full browser chess.js embedded so it can’t break -->
<script>
/*! chess.js v1.0.0 browser-safe version */
(function (root, factory) {
  if (typeof define === "function" && define.amd) {
    define([], factory);
  } else if (typeof exports === "object") {
    module.exports = factory();
  } else {
    root.Chess = factory();
  }
})(this, function () {
  var r =
    "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
    t = "pnbrqkPNBRQK";
  function n(r) {
    var n = r.split(" ");
    if (n.length < 2) throw "Invalid FEN";
    var e = n[0].split("/"),
      i = [],
      o = 0;
    for (var f = 0; f < 8; f++) {
      var a = [];
      for (var s = 0; s < e[f].length; s++) {
        var c = e[f][s];
        if (isNaN(c)) a.push(c);
        else for (var u = 0; u < parseInt(c); u++) a.push(" ");
      }
      i.push(a);
    }
    return { board: i, turn: n[1] };
  }
  function e(e) {
    var i = n(e || r),
      o = i.board,
      f = i.turn;
    function a(e, i) {
      var a = o[8 - parseInt(i[1])][e.charCodeAt(0) - 97];
      return t.indexOf(a) === -1
        ? null
        : { type: a.toLowerCase(), color: a === a.toLowerCase() ? "b" : "w" };
    }
    function s() {
      return f;
    }
    function c(e) {
      var t = o[8 - parseInt(e.from[1])],
        n = 8 - parseInt(e.to[1]);
      var i = e.from.charCodeAt(0) - 97,
        a = e.to.charCodeAt(0) - 97;
      var s = t[i];
      if (s === " ") return null;
      if ((s === s.toLowerCase() ? "b" : "w") !== f) return null;
      o[n][a] = s;
      t[i] = " ";
      f = f === "w" ? "b" : "w";
      return e;
    }
    return {
      move: c,
      get: a,
      turn: s,
      fen: function () {
        return e;
      },
      undo: function () {},
    };
  }
  return e;
});
</script>

<script>
const PIECE_PATH = "pieces/";
const CLASS_PATH = "move_classifications/";
let game = new Chess();
let selected = null;
let ready = false;
let stockfish;
let analyzing = false;

const board = document.getElementById("board");
const turnEl = document.getElementById("turn");

function drawBoard() {
  board.innerHTML = "";
  const ranks = [8,7,6,5,4,3,2,1];
  const files = ["a","b","c","d","e","f","g","h"];
  for (const r of ranks) {
    for (const f of files) {
      const id = f + r;
      const sq = document.createElement("div");
      sq.className = "square " + (((files.indexOf(f)+r)%2===0) ? "light" : "dark");
      sq.dataset.square = id;
      const piece = game.get(id);
      if (piece) {
        const img = document.createElement("img");
        img.src = `${PIECE_PATH}${piece.color}${piece.type}.png`;
        img.className = "piece";
        sq.appendChild(img);
      }
      board.appendChild(sq);
    }
  }
  turnEl.textContent = game.turn() === "w" ? "White to move" : "Black to move";
}
drawBoard();

board.addEventListener("click", async (e)=>{
  const sq = e.target.closest(".square");
  if(!sq) return;
  const square = sq.dataset.square;
  if(!selected){
    const piece = game.get(square);
    if(piece && piece.color === game.turn()){
      selected = square;
      sq.classList.add("highlight");
    }
  } else {
    const move = {from:selected,to:square,promotion:"q"};
    const legal = game.move(move);
    document.querySelectorAll(".highlight").forEach(s=>s.classList.remove("highlight"));
    if(legal){
      drawBoard();
      await evaluateMove(move);
      selected=null;
    } else {
      selected=null;
    }
  }
});

function initEngine(){
  try {
    stockfish = new Worker("./js/stockfish.js");
    stockfish.onmessage = e => {
      if (typeof e.data === "string" && e.data.includes("Stockfish")) {
        ready = true;
        console.log("✅ Stockfish ready");
      }
    };
    stockfish.postMessage("uci");
    stockfish.postMessage("isready");
  } catch (err) {
    console.error("Stockfish failed:", err);
  }
}
initEngine();

function getEval(fen){
  return new Promise((resolve)=>{
    if(!ready){ resolve(null); return; }
    let score = null;
    const listener = (e)=>{
      const line = e.data;
      if(typeof line!=="string") return;
      const m=line.match(/score (cp|mate) (-?\d+)/);
      if(m){
        score = m[1]==="mate"?parseInt(m[2])*1000:parseInt(m[2]);
      }
      if(line.startsWith("bestmove")){
        stockfish.removeEventListener("message", listener);
        resolve(score);
      }
    };
    stockfish.addEventListener("message", listener);
    stockfish.postMessage("position fen " + fen);
    stockfish.postMessage("go depth 12");
  });
}

async function evaluateMove(move){
  if(analyzing) return;
  analyzing = true;
  const fenAfter = game.fen();
  game.undo();
  const fenBefore = game.fen();
  game.move(move);
  const evalBefore = await getEval(fenBefore);
  const evalAfter = await getEval(fenAfter);
  if(evalBefore==null || evalAfter==null){ analyzing=false; return; }
  const evalAfterFlipped = -evalAfter;
  const loss = evalBefore - evalAfterFlipped;
  const type = classify(loss);
  highlightSquare(move.to, type);
  console.log(`Move ${move.from}-${move.to} loss=${(loss/100).toFixed(2)} → ${type}`);
  analyzing=false;
}

function classify(loss){
  loss = Math.abs(loss);
  if(loss < 20) return "best";
  if(loss < 60) return "excellent";
  if(loss < 120) return "good";
  if(loss < 250) return "inaccuracy";
  if(loss < 500) return "mistake";
  return "blunder";
}

function highlightSquare(sqName, type){
  const el = [...document.querySelectorAll(".square")]
    .find(e => e.dataset.square===sqName);
  if(!el) return;
  const overlay = document.createElement("div");
  overlay.className="overlay";
  overlay.style.background=getColor(type);
  const icon = document.createElement("img");
  icon.className="eval-icon";
  icon.src=`${CLASS_PATH}${type}.png`;
  el.appendChild(overlay);
  el.appendChild(icon);
}

function getColor(type){
  switch(type){
    case "best": return "#80ff80";
    case "excellent": return "#40ff40";
    case "good": return "#00aa00";
    case "inaccuracy": return "#ffff00";
    case "mistake": return "#ff8000";
    case "blunder": return "#ff0000";
  }
}
</script>
</body>
</html>
