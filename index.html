<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AlienGamer Chess</title>
<style>
  body {
    background:#111;color:#fff;font-family:Arial;
    display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;
  }
  #board{display:grid;grid-template-columns:repeat(8,80px);grid-template-rows:repeat(8,80px);
    border:4px solid #000;margin-bottom:20px;}
  .square{width:80px;height:80px;display:flex;justify-content:center;align-items:center;user-select:none;}
  .light{background:#f0d9b5;} .dark{background:#b58863;}
  .piece{width:72px;height:72px;cursor:grab;}
  #turn{font-size:1.3rem;letter-spacing:1px;}
</style>
</head>
<body>
<div id="board"></div>
<div id="turn">White to move</div>

<script>
const files=['a','b','c','d','e','f','g','h'];
const ranks=[8,7,6,5,4,3,2,1];
const board=document.getElementById('board');
const turnDisplay=document.getElementById('turn');

let startPos={
 a8:'br',b8:'bn',c8:'bb',d8:'bq',e8:'bk',f8:'bb',g8:'bn',h8:'br',
 a7:'bp',b7:'bp',c7:'bp',d7:'bp',e7:'bp',f7:'bp',g7:'bp',h7:'bp',
 a2:'wp',b2:'wp',c2:'wp',d2:'wp',e2:'wp',f2:'wp',g2:'wp',h2:'wp',
 a1:'wr',b1:'wn',c1:'wb',d1:'wq',e1:'wk',f1:'wb',g1:'wn',h1:'wr'
};
let gameState=structuredClone(startPos);
let turn='w';
let kingMoved={w:false,b:false};
let rookMoved={a1:false,h1:false,a8:false,h8:false};

function drawBoard(){
 board.innerHTML='';
 for(let r of ranks){
  for(let f of files){
   const sq=document.createElement('div');
   sq.classList.add('square');
   if((files.indexOf(f)+ranks.indexOf(r))%2===0)sq.classList.add('light');else sq.classList.add('dark');
   const id=f+r;sq.id=id;
   const piece=gameState[id];
   if(piece){
     const img=document.createElement('img');
     img.src=`pieces/${piece}.png`;img.classList.add('piece');img.draggable=true;
     sq.appendChild(img);
   }
   board.appendChild(sq);
  }
 }
 turnDisplay.textContent=(turn==='w')?'White to move':'Black to move';
 enableDragAndDrop();
}

function colorOf(p){return p?p[0]:null;}
function typeOf(p){return p?p[1]:null;}
function index(f){return files.indexOf(f);}
function clearPath(from,to){
 const fx=index(from[0]),fy=+from[1],tx=index(to[0]),ty=+to[1];
 const dx=Math.sign(tx-fx),dy=Math.sign(ty-fy);
 let x=fx+dx,y=fy+dy;
 while(x!==tx||y!==ty){
   if(gameState[files[x]+y])return false;
   x+=dx;y+=dy;
 }
 return true;
}
function squareAttacked(target,color){
 // check if any enemy piece could move to target
 for(const [sq,p] of Object.entries(gameState)){
   if(colorOf(p)!==color && isLegalMove(sq,target,true))return true;
 }
 return false;
}

function findKing(color){
 for(const [sq,p] of Object.entries(gameState))
   if(p===color+'k')return sq;
 return null;
}

function isKingInCheck(color){
 const kingSq=findKing(color);
 return squareAttacked(kingSq,color);
}

function wouldCauseCheck(from,to){
 const snapshot=structuredClone(gameState);
 gameState[to]=gameState[from];delete gameState[from];
 const check=isKingInCheck(colorOf(gameState[to]));
 gameState=structuredClone(snapshot);
 return check;
}

function isLegalMove(from,to,ignoreCheck=false){
 const piece=gameState[from];if(!piece)return false;
 const color=colorOf(piece),type=typeOf(piece);
 const fx=index(from[0]),fy=+from[1],tx=index(to[0]),ty=+to[1];
 const dx=tx-fx,dy=ty-fy,target=gameState[to];
 if(target&&colorOf(target)===color)return false;
 switch(type){
  case'p':{
   const dir=(color==='w')?1:-1;const start=(color==='w')?2:7;
   if(dx===0&&!target){
     if(ty-fy===dir)return true;
     if(fy===start&&ty-fy===2*dir&&!gameState[files[fx]+(fy+dir)])return true;
   }else if(Math.abs(dx)===1&&ty-fy===dir&&target)return true;
   return false;
  }
  case'r':if(fx===tx||fy===ty)return clearPath(from,to);return false;
  case'b':if(Math.abs(dx)===Math.abs(dy))return clearPath(from,to);return false;
  case'q':if(fx===tx||fy===ty||Math.abs(dx)===Math.abs(dy))return clearPath(from,to);return false;
  case'n':return(Math.abs(dx)===1&&Math.abs(dy)===2)||(Math.abs(dx)===2&&Math.abs(dy)===1);
  case'k':{
    if(Math.abs(dx)<=1&&Math.abs(dy)<=1)return true;
    // castling
    if(!ignoreCheck && !kingMoved[color]){
      if(dy===0 && Math.abs(dx)===2){
        const side=(dx>0)?'h':'a';
        const rookSq=side+(color==='w'?1:8);
        const rook=gameState[rookSq];
        if(rook===color+'r'&&!rookMoved[rookSq]){
          const between=(dx>0)?['f','g']:['b','c','d'];
          if(between.every(f=>!gameState[f+(color==='w'?1:8)]) &&
             !isKingInCheck(color) &&
             !between.some(f=>squareAttacked(f+(color==='w'?1:8),color))){
             return true;
          }
        }
      }
    }
    return false;
  }
 }
 return false;
}

function movePiece(from,to){
 const piece=gameState[from];
 const color=colorOf(piece);
 // castling move
 if(typeOf(piece)==='k' && Math.abs(index(to[0])-index(from[0]))===2){
   const y=(color==='w'?1:8);
   if(to==='g'+y){ // kingside
     gameState['f'+y]=gameState['h'+y];delete gameState['h'+y];
   }else if(to==='c'+y){ // queenside
     gameState['d'+y]=gameState['a'+y];delete gameState['a'+y];
   }
   kingMoved[color]=true;
 }
 if(typeOf(piece)==='r')rookMoved[from]=true;
 if(typeOf(piece)==='k')kingMoved[color]=true;
 gameState[to]=piece;delete gameState[from];
 // promotion
 if(typeOf(piece)==='p' && (to.endsWith('8')||to.endsWith('1')))
   gameState[to]=color+'q';
}

function noLegalMoves(color){
 for(const [sq,p] of Object.entries(gameState)){
   if(colorOf(p)!==color)continue;
   for(const f of files)for(const r of ranks){
     const t=f+r;
     if(isLegalMove(sq,t) && !wouldCauseCheck(sq,t))return false;
   }
 }
 return true;
}

function enableDragAndDrop(){
 let dragged=null,source=null;
 document.querySelectorAll('.piece').forEach(pc=>{
  pc.addEventListener('dragstart',e=>{
    const sq=e.target.parentElement.id;
    const p=gameState[sq];
    if(colorOf(p)!==turn){e.preventDefault();return;}
    dragged=e.target;source=sq;
    setTimeout(()=>dragged.style.visibility='hidden',0);
  });
  pc.addEventListener('dragend',e=>{if(dragged)dragged.style.visibility='visible';dragged=null;});
 });
 document.querySelectorAll('.square').forEach(sq=>{
  sq.addEventListener('dragover',e=>e.preventDefault());
  sq.addEventListener('drop',e=>{
   e.preventDefault();
   const target=e.target.closest('.square').id;
   if(!source||!dragged)return;
   if(isLegalMove(source,target)&&!wouldCauseCheck(source,target)){
     movePiece(source,target);
     turn=(turn==='w')?'b':'w';
     drawBoard();
     if(isKingInCheck(turn)){
       if(noLegalMoves(turn)){
         alert(`Checkmate! ${(turn==='w')?'Black':'White'} wins.`);
       }else{
         alert(`${turn==='w'?'White':'Black'} is in check!`);
       }
     }else if(noLegalMoves(turn)){
       alert('Stalemate!');
     }
   }
   source=null;
  });
 });
}

drawBoard();
</script>
</body>
</html>
