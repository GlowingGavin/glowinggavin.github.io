<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Seedfinding World</title>

<style>
  body {
    margin: 0;
    background: radial-gradient(circle at center, #0b0c11, #05060a 70%);
    color: #eaeaf0;
    font-family: system-ui, -apple-system, Segoe UI, sans-serif;
    overflow: hidden;
  }

  header {
    padding: 16px 20px;
    background: linear-gradient(90deg, #1a1c2b, #141625);
    box-shadow: 0 2px 12px rgba(0,0,0,0.6);
    position: relative;
    z-index: 10;
  }

  header h1 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    letter-spacing: 0.4px;
  }

  header input {
    margin-top: 10px;
    width: 100%;
    max-width: 420px;
    padding: 10px 12px;
    font-size: 15px;
    background: #0e0f14;
    color: #fff;
    border: 1px solid #2b2e4a;
    border-radius: 8px;
    outline: none;
  }

  canvas {
    display: block;
    margin: 0 auto;
    cursor: pointer;
  }
</style>
</head>

<body>
<header>
  <h1>Seedfinding World (4096Ã—4096)</h1>
  <input id="seed" spellcheck="false" value="123456789">
</header>

<canvas id="map" width="900" height="900"></canvas>

<script>
// ================= RNG =================
class SplitMix64 {
  constructor(seed) { this.state = BigInt.asUintN(64, seed); }
  next() {
    this.state = BigInt.asUintN(64, this.state + 0x9E3779B97F4A7C15n);
    let z = this.state;
    z = BigInt.asUintN(64, (z ^ (z >> 30n)) * 0xBF58476D1CE4E5B9n);
    z = BigInt.asUintN(64, (z ^ (z >> 27n)) * 0x94D049BB133111EBn);
    return BigInt.asUintN(64, z ^ (z >> 31n));
  }
  float() { return Number(this.next() >> 11n) / 2**53; }
}

// ================= CONFIG =================
const WORLD = 4096;
const HALF = WORLD / 2;
const REGION = 512;
const GRID = WORLD / REGION;
const q = 0.25;

const canvas = document.getElementById("map");
const ctx = canvas.getContext("2d");

let villages = [];
let selected = null;
let t = 0;

// ================= UTILS =================
function seedToU64(str) {
  try { return BigInt.asUintN(64, BigInt(str)); }
  catch { return 0n; }
}

function worldToCanvas(x, z) {
  return {
    x: (x + HALF) / WORLD * canvas.width,
    y: (z + HALF) / WORLD * canvas.height
  };
}

// rarity text (exactly k)
function rarityText(k) {
  const base = (4 ** (k + 1)) / 3;
  if (base < 1e6) return `1 in ${base.toFixed(0)}`;
  if (base < 1e9) return `1 in ${(base/1e6).toFixed(1)} million`;
  if (base < 1e12) return `1 in ${(base/1e9).toFixed(1)} billion`;
  if (base < 1e15) return `1 in ${(base/1e12).toFixed(1)} trillion`;
  return `1 in ${(base/1e15).toFixed(2)} quadrillion`;
}

// extended colors
function glowFor(k) {
  if (k <= 1) return "#7cff7c";
  if (k === 2) return "#ffd000";
  if (k === 3) return "#ff8c1a";
  if (k === 4) return "#ff2d2d";
  if (k === 5) return "#ff4bff";
  if (k <= 7) return "#8a2be2";
  if (k <= 10) return "#00e5ff";
  if (k <= 14) return "#adff2f";
  if (k <= 18) return "#ffd700";
  if (k <= 22) return "#ff6a00";
  if (k <= 26) return "#ff003c";
  return "#ffffff";
}

// clamp text to canvas
function clampText(x, y, text, font) {
  ctx.font = font;
  const w = ctx.measureText(text).width;
  const pad = 6;
  x = Math.max(pad, Math.min(canvas.width - w - pad, x));
  y = Math.max(16, Math.min(canvas.height - pad, y));
  return { x, y };
}

// ================= GENERATION =================
function generate(seedStr) {
  villages = [];
  selected = null;
  const rng = new SplitMix64(seedToU64(seedStr));

  for (let rx = 0; rx < GRID; rx++) {
    for (let rz = 0; rz < GRID; rz++) {
      if (rng.float() > 0.55) continue;

      const x = -HALF + rx * REGION + rng.float() * REGION;
      const z = -HALF + rz * REGION + rng.float() * REGION;

      let k = 0;
      while (rng.float() < q) k++;

      const p = worldToCanvas(x, z);
      villages.push({ x: p.x, y: p.y, k, color: glowFor(k) });
    }
  }
}

// ================= DRAW LOOP =================
function draw() {
  t += 0.016;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (const v of villages) {
    const pulse = selected === v ? 1 : 1 + Math.sin(t * 2 + v.k) * 0.15;
    const r = 3 + Math.min(v.k, 8) * pulse;

    // dot
    ctx.beginPath();
    ctx.fillStyle = v.color;
    ctx.shadowColor = v.color;
    ctx.shadowBlur = 14 + v.k * 4;
    ctx.arc(v.x, v.y, r, 0, Math.PI * 2);
    ctx.fill();

    // halo
    if (v.k >= 10) {
      ctx.beginPath();
      ctx.strokeStyle = v.color;
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.4;
      ctx.arc(v.x, v.y, r + 6 + Math.sin(t * 3) * 2, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // ALWAYS draw number
    ctx.font = "12px monospace";
    ctx.fillStyle = v.color;
    ctx.shadowBlur = 0;

    const num = String(v.k);
    const m = ctx.measureText(num);
    let nx = v.x + 6;
    let ny = v.y - 6;

    nx = Math.max(0, Math.min(canvas.width - m.width, nx));
    ny = Math.max(12, Math.min(canvas.height, ny));

    ctx.fillText(num, nx, ny);
  }

  // click HUD (ODDS ONLY)
  if (selected) {
    const odds = rarityText(selected.k);
    const p = clampText(
      selected.x - 60,
      selected.y - 28,
      odds,
      "14px system-ui"
    );

    ctx.font = "14px system-ui";
    ctx.fillStyle = selected.color;
    ctx.shadowColor = selected.color;
    ctx.shadowBlur = 12;
    ctx.fillText(odds, p.x, p.y);
  }

  requestAnimationFrame(draw);
}

// ================= INTERACTION =================
canvas.addEventListener("click", e => {
  const r = canvas.getBoundingClientRect();
  const mx = e.clientX - r.left;
  const my = e.clientY - r.top;

  selected = null;
  for (const v of villages) {
    const dx = mx - v.x;
    const dy = my - v.y;
    if (dx*dx + dy*dy < 100) {
      selected = v;
      break;
    }
  }
});

// ================= INIT =================
let timeout;
document.getElementById("seed").addEventListener("input", e => {
  clearTimeout(timeout);
  timeout = setTimeout(() => generate(e.target.value), 120);
});

generate(document.getElementById("seed").value);
draw();
</script>
</body>
</html>
